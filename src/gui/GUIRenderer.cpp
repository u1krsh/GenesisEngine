#include "GUIRenderer.h"
#include <glad/glad.h>
#include <cstring>
#include <algorithm>

namespace Genesis {
namespace GUI {

// Simple 8x12 bitmap font (ASCII 32-126)
// Each character is 8 pixels wide, stored as 12 bytes (one byte per row)
static const unsigned char g_fontData[] = {
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00,
    // " (34)
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // # (35)
    0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00,
    // $ (36)
    0x18, 0x7E, 0xC0, 0xC0, 0x7C, 0x06, 0x06, 0xFC, 0x18, 0x18, 0x00, 0x00,
    // % (37)
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x60, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // & (38)
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // ' (39)
    0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ( (40)
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00,
    // ) (41)
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00,
    // * (42)
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // + (43)
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00,
    // - (45)
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    // / (47)
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0 (48)
    0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 1 (49)
    0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 2 (50)
    0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // 3 (51)
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 4 (52)
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    // 5 (53)
    0xFE, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 6 (54)
    0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 7 (55)
    0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    // 8 (56)
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 9 (57)
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    // : (58)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ; (59)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    // < (60)
    0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00,
    // = (61)
    0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // > (62)
    0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00,
    // ? (63)
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // @ (64)
    0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // A (65)
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // B (66)
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    // C (67)
    0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // D (68)
    0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // E (69)
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // F (70)
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // G (71)
    0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    // H (72)
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // I (73)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // J (74)
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    // K (75)
    0xE6, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // L (76)
    0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // M (77)
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // N (78)
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // O (79)
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // P (80)
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Q (81)
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xCE, 0x7C, 0x0E, 0x00, 0x00, 0x00, 0x00,
    // R (82)
    0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // S (83)
    0x7C, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // T (84)
    0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // U (85)
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // V (86)
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // W (87)
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x82, 0x00, 0x00, 0x00, 0x00,
    // X (88)
    0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Y (89)
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Z (90)
    0xFE, 0xC6, 0x8C, 0x18, 0x30, 0x62, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // [ (91)
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // \ (92)
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ] (93)
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // ^ (94)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
    // ` (96)
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // a (97)
    0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // b (98)
    0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x00,
    // c (99)
    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // d (100)
    0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // e (101)
    0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // f (102)
    0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00,
    // g (103)
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00, 0x00, 0x00,
    // h (104)
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // i (105)
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // j (106)
    0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
    // k (107)
    0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // l (108)
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // m (109)
    0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0x00, 0x00, 0x00, 0x00,
    // n (110)
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // o (111)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // p (112)
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
    // q (113)
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00,
    // r (114)
    0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // s (115)
    0x00, 0x00, 0x7C, 0xC6, 0x70, 0x1C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // t (116)
    0x10, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    // u (117)
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // v (118)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // w (119)
    0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // x (120)
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // y (121)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00, 0x00, 0x00,
    // z (122)
    0x00, 0x00, 0xFE, 0x8C, 0x18, 0x30, 0x62, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // { (123)
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    // | (124)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // } (125)
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    // ~ (126)
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const char* g_guiVertexShader = R"(
#version 330 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aTexCoord;
layout (location = 2) in vec4 aColor;

out vec2 TexCoord;
out vec4 Color;

uniform mat4 u_Projection;

void main() {
    gl_Position = u_Projection * vec4(aPos, 0.0, 1.0);
    TexCoord = aTexCoord;
    Color = aColor;
}
)";

static const char* g_guiFragmentShader = R"(
#version 330 core
in vec2 TexCoord;
in vec4 Color;

out vec4 FragColor;

uniform sampler2D u_Texture;
uniform int u_UseTexture;

void main() {
    if (u_UseTexture == 1) {
        float alpha = texture(u_Texture, TexCoord).r;
        FragColor = vec4(Color.rgb, Color.a * alpha);
    } else {
        FragColor = Color;
    }
}
)";

bool GUIRenderer::Initialize() {
    if (m_initialized) return true;

    // Create shader
    m_shader = std::make_shared<Shader>();
    if (!m_shader->LoadFromSource(g_guiVertexShader, g_guiFragmentShader, "gui")) {
        return false;
    }

    // Create VAO/VBO
    glGenVertexArrays(1, &m_vao);
    glGenBuffers(1, &m_vbo);

    glBindVertexArray(m_vao);
    glBindBuffer(GL_ARRAY_BUFFER, m_vbo);

    // Position
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(GUIVertex), (void*)0);
    glEnableVertexAttribArray(0);
    // TexCoord
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(GUIVertex), (void*)(2 * sizeof(float)));
    glEnableVertexAttribArray(1);
    // Color
    glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, sizeof(GUIVertex), (void*)(4 * sizeof(float)));
    glEnableVertexAttribArray(2);

    glBindVertexArray(0);

    // Create font texture
    CreateFontTexture();

    m_initialized = true;
    return true;
}

void GUIRenderer::CreateFontTexture() {
    // Create a texture atlas for the font
    std::vector<unsigned char> textureData(FONT_TEXTURE_SIZE * FONT_TEXTURE_SIZE, 0);

    // 95 printable ASCII characters (32-126)
    int charsPerRow = FONT_TEXTURE_SIZE / FONT_CHAR_WIDTH;

    for (int c = 0; c < 95; c++) {
        int cx = (c % charsPerRow) * FONT_CHAR_WIDTH;
        int cy = (c / charsPerRow) * FONT_CHAR_HEIGHT;

        for (int row = 0; row < FONT_CHAR_HEIGHT; row++) {
            unsigned char rowData = (row < 12) ? g_fontData[c * 12 + row] : 0;
            for (int col = 0; col < FONT_CHAR_WIDTH; col++) {
                int px = cx + col;
                int py = cy + row;
                if (px < FONT_TEXTURE_SIZE && py < FONT_TEXTURE_SIZE) {
                    textureData[py * FONT_TEXTURE_SIZE + px] = (rowData & (0x80 >> col)) ? 255 : 0;
                }
            }
        }
    }

    glGenTextures(1, &m_fontTexture);
    glBindTexture(GL_TEXTURE_2D, m_fontTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, FONT_TEXTURE_SIZE, FONT_TEXTURE_SIZE, 0, GL_RED, GL_UNSIGNED_BYTE, textureData.data());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}

void GUIRenderer::Shutdown() {
    if (m_vao) { glDeleteVertexArrays(1, &m_vao); m_vao = 0; }
    if (m_vbo) { glDeleteBuffers(1, &m_vbo); m_vbo = 0; }
    if (m_fontTexture) { glDeleteTextures(1, &m_fontTexture); m_fontTexture = 0; }
    m_shader.reset();
    m_initialized = false;
}

void GUIRenderer::BeginFrame(int screenWidth, int screenHeight) {
    m_screenWidth = screenWidth;
    m_screenHeight = screenHeight;
    m_vertices.clear();
    m_clipStack.clear();
}

void GUIRenderer::EndFrame() {
    Flush();
}

void GUIRenderer::Flush() {
    if (m_vertices.empty()) return;

    // Setup state for 2D GUI rendering
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);  // Don't write to depth buffer
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_CULL_FACE);  // GUI quads may have any winding

    // Create orthographic projection
    Mat4 projection = glm::ortho(0.0f, (float)m_screenWidth, (float)m_screenHeight, 0.0f, -1.0f, 1.0f);

    m_shader->Bind();
    m_shader->SetMat4("u_Projection", projection);
    m_shader->SetInt("u_UseTexture", 0);

    glBindVertexArray(m_vao);
    glBindBuffer(GL_ARRAY_BUFFER, m_vbo);
    glBufferData(GL_ARRAY_BUFFER, m_vertices.size() * sizeof(GUIVertex), m_vertices.data(), GL_DYNAMIC_DRAW);

    glDrawArrays(GL_TRIANGLES, 0, static_cast<GLsizei>(m_vertices.size()));

    glBindVertexArray(0);
    m_shader->Unbind();

    // Restore state
    glEnable(GL_DEPTH_TEST);
    glDepthMask(GL_TRUE);
    glDisable(GL_BLEND);
    glEnable(GL_CULL_FACE);

    m_vertices.clear();
}

void GUIRenderer::AddVertex(float x, float y, float u, float v, const Vec4& color) {
    m_vertices.emplace_back(x, y, u, v, color);
}

void GUIRenderer::DrawRect(const Rect& rect, const Vec4& color) {
    // Two triangles
    AddVertex(rect.x, rect.y, 0, 0, color);
    AddVertex(rect.x + rect.width, rect.y, 1, 0, color);
    AddVertex(rect.x + rect.width, rect.y + rect.height, 1, 1, color);

    AddVertex(rect.x, rect.y, 0, 0, color);
    AddVertex(rect.x + rect.width, rect.y + rect.height, 1, 1, color);
    AddVertex(rect.x, rect.y + rect.height, 0, 1, color);
}

void GUIRenderer::DrawRectOutline(const Rect& rect, const Vec4& color, float thickness) {
    // Top
    DrawRect(Rect(rect.x, rect.y, rect.width, thickness), color);
    // Bottom
    DrawRect(Rect(rect.x, rect.y + rect.height - thickness, rect.width, thickness), color);
    // Left
    DrawRect(Rect(rect.x, rect.y, thickness, rect.height), color);
    // Right
    DrawRect(Rect(rect.x + rect.width - thickness, rect.y, thickness, rect.height), color);
}

void GUIRenderer::DrawRectGradientV(const Rect& rect, const Vec4& topColor, const Vec4& bottomColor) {
    AddVertex(rect.x, rect.y, 0, 0, topColor);
    AddVertex(rect.x + rect.width, rect.y, 1, 0, topColor);
    AddVertex(rect.x + rect.width, rect.y + rect.height, 1, 1, bottomColor);

    AddVertex(rect.x, rect.y, 0, 0, topColor);
    AddVertex(rect.x + rect.width, rect.y + rect.height, 1, 1, bottomColor);
    AddVertex(rect.x, rect.y + rect.height, 0, 1, bottomColor);
}

void GUIRenderer::DrawRectGradientH(const Rect& rect, const Vec4& leftColor, const Vec4& rightColor) {
    AddVertex(rect.x, rect.y, 0, 0, leftColor);
    AddVertex(rect.x + rect.width, rect.y, 1, 0, rightColor);
    AddVertex(rect.x + rect.width, rect.y + rect.height, 1, 1, rightColor);

    AddVertex(rect.x, rect.y, 0, 0, leftColor);
    AddVertex(rect.x + rect.width, rect.y + rect.height, 1, 1, rightColor);
    AddVertex(rect.x, rect.y + rect.height, 0, 1, leftColor);
}

void GUIRenderer::DrawBorder3D(const Rect& rect, bool raised) {
    Vec4 light = raised ? Colors::BorderLight : Colors::BorderDark;
    Vec4 dark = raised ? Colors::BorderDark : Colors::BorderLight;

    // Top and left (light)
    DrawRect(Rect(rect.x, rect.y, rect.width, 1), light);
    DrawRect(Rect(rect.x, rect.y, 1, rect.height), light);

    // Bottom and right (dark)
    DrawRect(Rect(rect.x, rect.y + rect.height - 1, rect.width, 1), dark);
    DrawRect(Rect(rect.x + rect.width - 1, rect.y, 1, rect.height), dark);
}

void GUIRenderer::DrawText(const std::string& text, float x, float y, const Vec4& color, float scale) {
    Flush();  // Flush non-text geometry first

    // Setup for text rendering
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_CULL_FACE);

    Mat4 projection = glm::ortho(0.0f, (float)m_screenWidth, (float)m_screenHeight, 0.0f, -1.0f, 1.0f);

    m_shader->Bind();
    m_shader->SetMat4("u_Projection", projection);
    m_shader->SetInt("u_UseTexture", 1);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, m_fontTexture);

    float charWidth = FONT_CHAR_WIDTH * scale;
    float charHeight = FONT_CHAR_HEIGHT * scale;
    float texCharWidth = (float)FONT_CHAR_WIDTH / FONT_TEXTURE_SIZE;
    float texCharHeight = (float)FONT_CHAR_HEIGHT / FONT_TEXTURE_SIZE;
    int charsPerRow = FONT_TEXTURE_SIZE / FONT_CHAR_WIDTH;

    float cursorX = x;
    for (char c : text) {
        if (c < 32 || c > 126) {
            cursorX += charWidth;
            continue;
        }

        int charIndex = c - 32;
        float tx = (charIndex % charsPerRow) * texCharWidth;
        float ty = (charIndex / charsPerRow) * texCharHeight;

        AddVertex(cursorX, y, tx, ty, color);
        AddVertex(cursorX + charWidth, y, tx + texCharWidth, ty, color);
        AddVertex(cursorX + charWidth, y + charHeight, tx + texCharWidth, ty + texCharHeight, color);

        AddVertex(cursorX, y, tx, ty, color);
        AddVertex(cursorX + charWidth, y + charHeight, tx + texCharWidth, ty + texCharHeight, color);
        AddVertex(cursorX, y + charHeight, tx, ty + texCharHeight, color);

        cursorX += charWidth;
    }

    // Render text
    glBindVertexArray(m_vao);
    glBindBuffer(GL_ARRAY_BUFFER, m_vbo);
    glBufferData(GL_ARRAY_BUFFER, m_vertices.size() * sizeof(GUIVertex), m_vertices.data(), GL_DYNAMIC_DRAW);
    glDrawArrays(GL_TRIANGLES, 0, static_cast<GLsizei>(m_vertices.size()));
    glBindVertexArray(0);

    m_vertices.clear();
    m_shader->Unbind();

    // Restore state
    glEnable(GL_DEPTH_TEST);
    glDepthMask(GL_TRUE);
    glEnable(GL_CULL_FACE);
}

void GUIRenderer::DrawTextCentered(const std::string& text, const Rect& rect, const Vec4& color, float scale) {
    Vec2 textSize = MeasureText(text, scale);
    float x = rect.x + (rect.width - textSize.x) / 2.0f;
    float y = rect.y + (rect.height - textSize.y) / 2.0f;
    DrawText(text, x, y, color, scale);
}

Vec2 GUIRenderer::MeasureText(const std::string& text, float scale) const {
    float width = text.length() * FONT_CHAR_WIDTH * scale;
    float height = FONT_CHAR_HEIGHT * scale;
    return Vec2(width, height);
}

float GUIRenderer::GetFontHeight(float scale) const {
    return FONT_CHAR_HEIGHT * scale;
}

void GUIRenderer::PushClipRect(const Rect& rect) {
    m_clipStack.push_back(rect);
    glEnable(GL_SCISSOR_TEST);
    glScissor(static_cast<int>(rect.x),
              m_screenHeight - static_cast<int>(rect.y + rect.height),
              static_cast<int>(rect.width),
              static_cast<int>(rect.height));
}

void GUIRenderer::PopClipRect() {
    if (!m_clipStack.empty()) {
        m_clipStack.pop_back();
    }
    if (m_clipStack.empty()) {
        glDisable(GL_SCISSOR_TEST);
    } else {
        const auto& rect = m_clipStack.back();
        glScissor(static_cast<int>(rect.x),
                  m_screenHeight - static_cast<int>(rect.y + rect.height),
                  static_cast<int>(rect.width),
                  static_cast<int>(rect.height));
    }
}

} // namespace GUI
} // namespace Genesis

